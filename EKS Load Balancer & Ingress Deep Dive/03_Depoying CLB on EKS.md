
---

#  Lesson 3: Deploying a Classic Load Balancer (CLB) on EKS Using Kubernetes Service

<img width="1024" height="1024" alt="image" src="https://github.com/user-attachments/assets/24cd0391-fdac-431c-832d-412f31df1ed5" />


---

##  Context

In this lesson, you're building on top of the previous foundational setup — your **EKS cluster is running with private node groups**, and your **RDS MySQL database is already provisioned**. The goal now is to expose the **user management REST API** application (running as Pods) to the internet using a **Kubernetes Service of type LoadBalancer** — which by default, provisions an **AWS Classic Load Balancer (CLB)**.

This is one of the most basic, cloud-integrated ways Kubernetes exposes workloads in EKS — simple yet essential to understand before moving on to advanced L7 ingress options like ALB.

---

##  Concept: What are we solving here?

So far:

* Pods are running in **private subnets**.
* They are connected to an **RDS database** using `ExternalName` Service.
* But access to these Pods is **not exposed externally**.

The solution:

* Create a Kubernetes `Service` of type `LoadBalancer` that:

  * Triggers AWS to create a **Classic Load Balancer**.
  * Listens on port `80` (standard HTTP) and routes traffic to backend Pods on port `8095`.
  * Provides a **DNS URL** you can test with a browser or Postman.
  * Automatically sets up health checks and registers the backend EC2 nodes with CLB.

---

##  High-Level Flow: CLB End-to-End Architecture

```
[Browser/Postman]
      │
      ▼
[CLB DNS: http://<elb>.amazonaws.com]
      │
      ▼
K8s Service (type: LoadBalancer)
  - Listens on port 80
  - Forwards to Pods (targetPort 8095)
      │
      ▼
[Pod: usermgmt-restapp]
      │
      ▼
[MySQL DB via ExternalName Service → RDS]
```

---

##  LAB: Deploy CLB + Microservice + DB Integration

###  File: `04-ClassicLoadBalancer.yml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: clb-usermgmt-restapp
  labels:
    app: usermgmt-restapp
spec:
  type: LoadBalancer  # <-- Key change from NodePort
  selector:
    app: usermgmt-restapp
  ports:
  - port: 80          # Browser standard port
    targetPort: 8095  # Your container’s port
```

>  This manifest replaces your older NodePort service with a cleaner CLB-based solution. No need for browser users to type a custom port.

---

### Step-by-Step Instructions

####  Step 1: Deploy All Components

```bash
kubectl apply -f kube-manifests/
```

This should include:

* `user-mgmt-restapp` Deployment
* RDS `ExternalName` Service
* Kubernetes `Secret` (if DB credentials used)
* `04-ClassicLoadBalancer.yml` Service

---

####  Step 2: Verify the CLB Creation

```bash
kubectl get svc
kubectl get pods
```

 Look for the `EXTERNAL-IP` in the `clb-usermgmt-restapp` service — this is your **CLB DNS URL**.

Now go to AWS Console:

* **EC2 → Load Balancers**
* You should see a new Load Balancer of type **Classic**
* Click into it → Check **Instances** tab
* Wait for backend nodes to turn **InService**

---

####  Step 3: Test Application End-to-End

Browser Test:

```http
http://<CLB-DNS>/usermgmt/health-status
```

Postman Test:

1. Create a new environment → Add key `URL` with value `http://<CLB-DNS>`
2. Run **Create User API**
3. Run **List Users API**
4. Observe backend call to **RDS via ExternalName service**

Expected: Full E2E flow from browser → CLB → Pod → RDS MySQL ✅

---

####  Step 4: Clean Up

```bash
kubectl delete -f kube-manifests/
```

AWS Console:

* Confirm the **CLB** also disappears automatically.

>  Everything is cleanly managed from Kubernetes. No need to touch AWS manually.

---

##  Key Takeaways

| Topic                | Detail                                              |
| -------------------- | --------------------------------------------------- |
| Exposure Type        | `Service type: LoadBalancer`                        |
| Cloud LB Provisioned | **Classic Load Balancer** (default on AWS)          |
| Protocols            | TCP/HTTP supported                                  |
| Port                 | External: `80` → Internal: `8095`                   |
| DNS                  | Auto-generated by AWS (can be mapped to Route53)    |
| Health Checks        | Done at node-level (status: `InService`)            |
| Security             | All Pods stay in private subnet; only CLB is public |
| Testing Tools        | Browser, Postman, `kubectl logs`, `kubectl get svc` |

---

##  What’s next in Lesson 4?

 Now that you’ve seen Classic LB in action, the next step is to upgrade to **Network Load Balancer (NLB)** for better performance, L4 control, and IP targeting. You’ll learn how to trigger NLB using Service annotations and compare its behavior to CLB.

---

